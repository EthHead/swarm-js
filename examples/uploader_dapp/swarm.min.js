(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// TODO: this is a temporary fix to hide those libraries from the browser. A
// slightly better long-term solution would be to split this file into two,
// separating the functions that are used on Node.js from the functions that
// are used only on the browser.
module.exports = function (_ref) {
  var fs = _ref.fs,
      files = _ref.files,
      os = _ref.os,
      path = _ref.path,
      child_process = _ref.child_process,
      mimetype = _ref.mimetype,
      defaultArchives = _ref.defaultArchives,
      request = _ref.request,
      downloadUrl = _ref.downloadUrl,
      bytes = _ref.bytes,
      hash = _ref.hash,
      pick = _ref.pick;


  // ∀ a . String -> JSON -> Map String a -o Map String a
  //   Inserts a key/val pair in an object impurely.
  var impureInsert = function impureInsert(key) {
    return function (val) {
      return function (map) {
        return map[key] = val, map;
      };
    };
  };

  // String -> JSON -> Map String JSON
  //   Merges an array of keys and an array of vals into an object.
  var toMap = function toMap(keys) {
    return function (vals) {
      var map = {};
      for (var i = 0, l = keys.length; i < l; ++i) {
        map[keys[i]] = vals[i];
      }return map;
    };
  };

  // ∀ a . Map String a -> Map String a -> Map String a
  //   Merges two maps into one.
  var merge = function merge(a) {
    return function (b) {
      var map = {};
      for (var key in a) {
        map[key] = a[key];
      }for (var _key in b) {
        map[_key] = b[_key];
      }return map;
    };
  };

  // ∀ a . [a] -> [a] -> Bool
  var equals = function equals(a) {
    return function (b) {
      if (a.length !== b.length) {
        return false;
      } else {
        for (var i = 0, l = a.length; i < a; ++i) {
          if (a[i] !== b[i]) return false;
        }
      }
      return true;
    };
  };

  // String -> String -> String
  var rawUrl = function rawUrl(swarmUrl) {
    return function (hash) {
      return swarmUrl + "/bzzr:/" + hash;
    };
  };

  // String -> String -> Promise Uint8Array
  //   Gets the raw contents of a Swarm hash address.
  var downloadData = function downloadData(swarmUrl) {
    return function (hash) {
      return request(rawUrl(swarmUrl)(hash), { responseType: "arraybuffer" }).then(function (arrayBuffer) {
        var uint8Array = new Uint8Array(arrayBuffer);
        var error404 = [52, 48, 52, 32, 112, 97, 103, 101, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 10];
        if (equals(uint8Array)(error404)) throw "Error 404.";
        return uint8Array;
      });
    };
  };

  // type Entry = {"type": String, "hash": String}
  // type File = {"type": String, "data": Uint8Array}

  // String -> String -> Promise (Map String Entry)
  //   Solves the manifest of a Swarm address recursively.
  //   Returns a map from full paths to entries.
  var downloadEntries = function downloadEntries(swarmUrl) {
    return function (hash) {
      var search = function search(hash) {
        return function (path) {
          return function (routes) {
            // Formats an entry to the Swarm.js type.
            var format = function format(entry) {
              return {
                type: entry.contentType,
                hash: entry.hash };
            };

            // To download a single entry:
            //   if type is bzz-manifest, go deeper
            //   if not, add it to the routing table
            var downloadEntry = function downloadEntry(entry) {
              if (entry.path === undefined) {
                return Promise.resolve();
              } else {
                return entry.contentType === "application/bzz-manifest+json" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));
              }
            };

            // Downloads the initial manifest and then each entry.
            return downloadData(swarmUrl)(hash).then(function (text) {
              return JSON.parse(toString(text)).entries;
            }).then(function (entries) {
              return Promise.all(entries.map(downloadEntry));
            }).then(function () {
              return routes;
            });
          };
        };
      };

      return search(hash)("")({});
    };
  };

  // String -> String -> Promise (Map String String)
  //   Same as `downloadEntries`, but returns only hashes (no types).
  var downloadRoutes = function downloadRoutes(swarmUrl) {
    return function (hash) {
      return downloadEntries(swarmUrl)(hash).then(function (entries) {
        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {
          return entries[route].hash;
        }));
      });
    };
  };

  // String -> String -> Promise (Map String File)
  //   Gets the entire directory tree in a Swarm address.
  //   Returns a promise mapping paths to file contents.
  var downloadDirectory = function downloadDirectory(swarmUrl) {
    return function (hash) {
      return downloadEntries(swarmUrl)(hash).then(function (entries) {
        var paths = Object.keys(entries);
        var hashs = paths.map(function (path) {
          return entries[path].hash;
        });
        var types = paths.map(function (path) {
          return entries[path].type;
        });
        var datas = hashs.map(downloadData(swarmUrl));
        var files = function files(datas) {
          return datas.map(function (data, i) {
            return { type: types[i], data: data };
          });
        };
        return Promise.all(datas).then(function (datas) {
          return toMap(paths)(files(datas));
        });
      });
    };
  };

  // String -> String -> String -> Promise String
  //   Gets the raw contents of a Swarm hash address.
  //   Returns a promise with the downloaded file path.
  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {
    return function (hash) {
      return function (filePath) {
        return files.download(rawUrl(swarmUrl)(hash))(filePath);
      };
    };
  };

  // String -> String -> String -> Promise (Map String String)
  //   Gets the entire directory tree in a Swarm address.
  //   Returns a promise mapping paths to file contents.
  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {
    return function (hash) {
      return function (dirPath) {
        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {
          var downloads = [];
          for (var route in routingTable) {
            if (route.length > 0) {
              var filePath = path.join(dirPath, route);
              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));
            };
          };
          return Promise.all(downloads).then(function () {
            return dirPath;
          });
        });
      };
    };
  };

  // String -> Uint8Array -> Promise String
  //   Uploads raw data to Swarm.
  //   Returns a promise with the uploaded hash.
  var uploadData = function uploadData(swarmUrl) {
    return function (data) {
      return request(swarmUrl + "/bzzr:/", {
        body: typeof data === "string" ? fromString(data) : data,
        method: "POST" });
    };
  };

  // String -> String -> String -> File -> Promise String
  //   Uploads a file to the Swarm manifest at a given hash, under a specific
  //   route. Returns a promise containing the uploaded hash.
  //   FIXME: for some reasons Swarm-Gateways is sometimes returning
  //   error 404 (bad request), so we retry up to 3 times. Why?
  var uploadToManifest = function uploadToManifest(swarmUrl) {
    return function (hash) {
      return function (route) {
        return function (file) {
          var attempt = function attempt(n) {
            var slashRoute = route[0] === "/" ? route : "/" + route;
            var url = swarmUrl + "/bzz:/" + hash + slashRoute;
            var opt = {
              method: "PUT",
              headers: { "Content-Type": file.type },
              body: file.data };
            return request(url, opt).then(function (response) {
              if (response.indexOf("error") !== -1) {
                throw response;
              }
              return response;
            }).catch(function (e) {
              return n > 0 && attempt(n - 1);
            });
          };
          return attempt(3);
        };
      };
    };
  };

  // String -> {type: String, data: Uint8Array} -> Promise String
  var uploadFile = function uploadFile(swarmUrl) {
    return function (file) {
      return uploadDirectory(swarmUrl)({ "": file });
    };
  };

  // String -> String -> Promise String
  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {
    return function (filePath) {
      return fs.readFile(filePath).then(function (data) {
        return uploadFile(swarmUrl)({ type: mimetype.lookup(filePath), data: data });
      });
    };
  };

  // String -> Map String File -> Promise String
  //   Uploads a directory to Swarm. The directory is
  //   represented as a map of routes and files.
  //   A default path is encoded by having a "" route.
  var uploadDirectory = function uploadDirectory(swarmUrl) {
    return function (directory) {
      return uploadData(swarmUrl)("{}").then(function (hash) {
        var uploadRoute = function uploadRoute(route) {
          return function (hash) {
            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);
          };
        };
        var uploadToHash = function uploadToHash(hash, route) {
          return hash.then(uploadRoute(route));
        };
        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));
      });
    };
  };

  // String -> Promise String
  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {
    return function (filePath) {
      return fs.readFile(filePath).then(uploadData(swarmUrl));
    };
  };

  // String -> Nullable String -> String -> Promise String
  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {
    return function (defaultPath) {
      return function (dirPath) {
        return files.directoryTree(dirPath).then(function (fullPaths) {
          return Promise.all(fullPaths.map(function (path) {
            return fs.readFile(path);
          })).then(function (datas) {
            var paths = fullPaths.map(function (path) {
              return path.slice(dirPath.length);
            });
            var types = fullPaths.map(function (path) {
              return mimetype.lookup(path) || "text/plain";
            });
            return toMap(paths)(datas.map(function (data, i) {
              return { type: types[i], data: data };
            }));
          });
        }).then(function (directory) {
          return merge(defaultPath ? { "": directory[defaultPath] } : {})(directory);
        }).then(uploadDirectory(swarmUrl));
      };
    };
  };

  // String -> UploadInfo -> Promise String
  //   Simplified multi-type upload which calls the correct
  //   one based on the type of the argument given.
  var _upload = function _upload(swarmUrl) {
    return function (arg) {
      // Upload raw data from browser
      if (arg.pick === "data") {
        return pick.data().then(uploadData(swarmUrl));

        // Upload a file from browser
      } else if (arg.pick === "file") {
        return pick.file().then(uploadFile(swarmUrl));

        // Upload a directory from browser
      } else if (arg.pick === "directory") {
        return pick.directory().then(uploadDirectory(swarmUrl));

        // Upload directory/file from disk
      } else if (arg.path) {
        switch (arg.kind) {
          case "data":
            return uploadDataFromDisk(swarmUrl)(arg.path);
          case "file":
            return uploadFileFromDisk(swarmUrl)(arg.path);
          case "directory":
            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);
        };

        // Upload UTF-8 string or raw data (buffer)
      } else if (arg.length || typeof arg === "string") {
        return uploadData(swarmUrl)(arg);

        // Upload directory with JSON
      } else if (arg instanceof Object) {
        return uploadDirectory(swarmUrl)(arg);
      }

      return Promise.reject(new Error("Bad arguments"));
    };
  };

  // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)
  //   Simplified multi-type download which calls the correct function based on
  //   the type of the argument given, and on whether the Swwarm address has a
  //   directory or a file.
  var _download = function _download(swarmUrl) {
    return function (hash) {
      return function (path) {
        return isDirectory(swarmUrl)(hash).then(function (isDir) {
          if (isDir) {
            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);
          } else {
            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);
          }
        });
      };
    };
  };

  // String -> Promise String
  //   Downloads the Swarm binaries into a path. Returns a promise that only
  //   resolves when the exact Swarm file is there, and verified to be correct.
  //   If it was already there to begin with, skips the download.
  var downloadBinary = function downloadBinary(path, archives) {
    var system = os.platform().replace("win32", "windows") + "-" + (os.arch() === "x64" ? "amd64" : "386");
    var archive = (archives || defaultArchives)[system];
    var archiveUrl = downloadUrl + archive.archive + ".tar.gz";
    var archiveMD5 = archive.archiveMD5;
    var binaryMD5 = archive.binaryMD5;
    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);
  };

  // type SwarmSetup = {
  //   account : String,
  //   password : String,
  //   dataDir : String,
  //   binPath : String,
  //   ensApi : String,
  //   onDownloadProgress : Number ~> (),
  //   archives : [{
  //     archive: String,
  //     binaryMD5: String,
  //     archiveMD5: String
  //   }]
  // }

  // SwarmSetup ~> Promise Process
  //   Starts the Swarm process.
  var startProcess = function startProcess(swarmSetup) {
    return new Promise(function (resolve, reject) {
      var spawn = child_process.spawn;


      var hasString = function hasString(str) {
        return function (buffer) {
          return ('' + buffer).indexOf(str) !== -1;
        };
      };
      var account = swarmSetup.account,
          password = swarmSetup.password,
          dataDir = swarmSetup.dataDir,
          ensApi = swarmSetup.ensApi,
          privateKey = swarmSetup.privateKey;


      var STARTUP_TIMEOUT_SECS = 3;
      var WAITING_PASSWORD = 0;
      var STARTING = 1;
      var LISTENING = 2;
      var PASSWORD_PROMPT_HOOK = "Passphrase";
      var LISTENING_HOOK = "Swarm http proxy started";

      var state = WAITING_PASSWORD;

      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);

      var handleProcessOutput = function handleProcessOutput(data) {
        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {
          setTimeout(function () {
            state = STARTING;
            swarmProcess.stdin.write(password + '\n');
          }, 500);
        } else if (hasString(LISTENING_HOOK)(data)) {
          state = LISTENING;
          clearTimeout(timeout);
          resolve(swarmProcess);
        }
      };

      swarmProcess.stdout.on('data', handleProcessOutput);
      swarmProcess.stderr.on('data', handleProcessOutput);
      //swarmProcess.on('close', () => setTimeout(restart, 2000));

      var restart = function restart() {
        return startProcess(swarmSetup).then(resolve).catch(reject);
      };
      var error = function error() {
        return reject(new Error("Couldn't start swarm process."));
      };
      var timeout = setTimeout(error, 20000);
    });
  };

  // Process ~> Promise ()
  //   Stops the Swarm process.
  var stopProcess = function stopProcess(process) {
    return new Promise(function (resolve, reject) {
      process.stderr.removeAllListeners('data');
      process.stdout.removeAllListeners('data');
      process.stdin.removeAllListeners('error');
      process.removeAllListeners('error');
      process.removeAllListeners('exit');
      process.kill('SIGINT');

      var killTimeout = setTimeout(function () {
        return process.kill('SIGKILL');
      }, 8000);

      process.once('close', function () {
        clearTimeout(killTimeout);
        resolve();
      });
    });
  };

  // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()
  //   Receives a Swarm configuration object and a callback function. It then
  //   checks if a local Swarm node is running. If no local Swarm is found, it
  //   downloads the Swarm binaries to the dataDir (if not there), checksums,
  //   starts the Swarm process and calls the callback function with an API
  //   object using the local node. That callback must return a promise which
  //   will resolve when it is done using the API, so that this function can
  //   close the Swarm process properly. Returns a promise that resolves when the
  //   user is done with the API and the Swarm process is closed.
  //   TODO: check if Swarm process is already running (improve `isAvailable`)
  var local = function local(swarmSetup) {
    return function (useAPI) {
      return _isAvailable("http://localhost:8500").then(function (isAvailable) {
        return isAvailable ? useAPI(at("http://localhost:8500")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {
          return (swarmSetup.onProgress || function () {})(data.length);
        }).then(function () {
          return startProcess(swarmSetup);
        }).then(function (process) {
          return useAPI(at("http://localhost:8500")).then(function () {
            return process;
          });
        }).then(stopProcess);
      });
    };
  };

  // String ~> Promise Bool
  //   Returns true if Swarm is available on `url`.
  //   Perfoms a test upload to determine that.
  //   TODO: improve this?
  var _isAvailable = function _isAvailable(swarmUrl) {
    var testFile = "test";
    var testHash = "c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7";
    return uploadData(swarmUrl)(testFile).then(function (hash) {
      return hash === testHash;
    }).catch(function () {
      return false;
    });
  };

  // String -> String ~> Promise Bool
  //   Returns a Promise which is true if that Swarm address is a directory.
  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.
  //   TODO: improve this?
  var isDirectory = function isDirectory(swarmUrl) {
    return function (hash) {
      return downloadData(swarmUrl)(hash).then(function (data) {
        try {
          return !!JSON.parse(toString(data)).entries;
        } catch (e) {
          return false;
        }
      });
    };
  };

  // Uncurries a function; used to allow the f(x,y,z) style on exports.
  var uncurry = function uncurry(f) {
    return function (a, b, c, d, e) {
      var p;
      // Hardcoded because efficiency (`arguments` is very slow).
      if (typeof a !== "undefined") p = f(a);
      if (typeof b !== "undefined") p = f(b);
      if (typeof c !== "undefined") p = f(c);
      if (typeof d !== "undefined") p = f(d);
      if (typeof e !== "undefined") p = f(e);
      return p;
    };
  };

  // () -> Promise Bool
  //   Not sure how to mock Swarm to test it properly. Ideas?
  var test = function test() {
    return Promise.resolve(true);
  };

  // Uint8Array -> String
  var toString = function toString(uint8Array) {
    return bytes.toString(bytes.fromUint8Array(uint8Array));
  };

  // String -> Uint8Array
  var fromString = function fromString(string) {
    return bytes.toUint8Array(bytes.fromString(string));
  };

  // String -> SwarmAPI
  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.
  var at = function at(swarmUrl) {
    return {
      download: function download(hash, path) {
        return _download(swarmUrl)(hash)(path);
      },
      downloadData: uncurry(downloadData(swarmUrl)),
      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),
      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),
      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),
      downloadEntries: uncurry(downloadEntries(swarmUrl)),
      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),
      isAvailable: function isAvailable() {
        return _isAvailable(swarmUrl);
      },
      upload: function upload(arg) {
        return _upload(swarmUrl)(arg);
      },
      uploadData: uncurry(uploadData(swarmUrl)),
      uploadFile: uncurry(uploadFile(swarmUrl)),
      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),
      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),
      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),
      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),
      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),
      pick: pick,
      hash: hash,
      fromString: fromString,
      toString: toString
    };
  };

  return {
    at: at,
    local: local,
    download: _download,
    downloadBinary: downloadBinary,
    downloadData: downloadData,
    downloadDataToDisk: downloadDataToDisk,
    downloadDirectory: downloadDirectory,
    downloadDirectoryToDisk: downloadDirectoryToDisk,
    downloadEntries: downloadEntries,
    downloadRoutes: downloadRoutes,
    isAvailable: _isAvailable,
    startProcess: startProcess,
    stopProcess: stopProcess,
    upload: _upload,
    uploadData: uploadData,
    uploadDataFromDisk: uploadDataFromDisk,
    uploadFile: uploadFile,
    uploadFileFromDisk: uploadFileFromDisk,
    uploadDirectory: uploadDirectory,
    uploadDirectoryFromDisk: uploadDirectoryFromDisk,
    uploadToManifest: uploadToManifest,
    pick: pick,
    hash: hash,
    fromString: fromString,
    toString: toString
  };
};
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvc3dhcm0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIFRPRE86IHRoaXMgaXMgYSB0ZW1wb3JhcnkgZml4IHRvIGhpZGUgdGhvc2UgbGlicmFyaWVzIGZyb20gdGhlIGJyb3dzZXIuIEFcbi8vIHNsaWdodGx5IGJldHRlciBsb25nLXRlcm0gc29sdXRpb24gd291bGQgYmUgdG8gc3BsaXQgdGhpcyBmaWxlIGludG8gdHdvLFxuLy8gc2VwYXJhdGluZyB0aGUgZnVuY3Rpb25zIHRoYXQgYXJlIHVzZWQgb24gTm9kZS5qcyBmcm9tIHRoZSBmdW5jdGlvbnMgdGhhdFxuLy8gYXJlIHVzZWQgb25seSBvbiB0aGUgYnJvd3Nlci5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGZzID0gX3JlZi5mcyxcbiAgICAgIGZpbGVzID0gX3JlZi5maWxlcyxcbiAgICAgIG9zID0gX3JlZi5vcyxcbiAgICAgIHBhdGggPSBfcmVmLnBhdGgsXG4gICAgICBjaGlsZF9wcm9jZXNzID0gX3JlZi5jaGlsZF9wcm9jZXNzLFxuICAgICAgbWltZXR5cGUgPSBfcmVmLm1pbWV0eXBlLFxuICAgICAgZGVmYXVsdEFyY2hpdmVzID0gX3JlZi5kZWZhdWx0QXJjaGl2ZXMsXG4gICAgICByZXF1ZXN0ID0gX3JlZi5yZXF1ZXN0LFxuICAgICAgZG93bmxvYWRVcmwgPSBfcmVmLmRvd25sb2FkVXJsLFxuICAgICAgYnl0ZXMgPSBfcmVmLmJ5dGVzLFxuICAgICAgaGFzaCA9IF9yZWYuaGFzaCxcbiAgICAgIHBpY2sgPSBfcmVmLnBpY2s7XG5cblxuICAvLyDiiIAgYSAuIFN0cmluZyAtPiBKU09OIC0+IE1hcCBTdHJpbmcgYSAtbyBNYXAgU3RyaW5nIGFcbiAgLy8gICBJbnNlcnRzIGEga2V5L3ZhbCBwYWlyIGluIGFuIG9iamVjdCBpbXB1cmVseS5cbiAgdmFyIGltcHVyZUluc2VydCA9IGZ1bmN0aW9uIGltcHVyZUluc2VydChrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIG1hcFtrZXldID0gdmFsLCBtYXA7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IEpTT04gLT4gTWFwIFN0cmluZyBKU09OXG4gIC8vICAgTWVyZ2VzIGFuIGFycmF5IG9mIGtleXMgYW5kIGFuIGFycmF5IG9mIHZhbHMgaW50byBhbiBvYmplY3QuXG4gIHZhciB0b01hcCA9IGZ1bmN0aW9uIHRvTWFwKGtleXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHMpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgbWFwW2tleXNbaV1dID0gdmFsc1tpXTtcbiAgICAgIH1yZXR1cm4gbWFwO1xuICAgIH07XG4gIH07XG5cbiAgLy8g4oiAIGEgLiBNYXAgU3RyaW5nIGEgLT4gTWFwIFN0cmluZyBhIC0+IE1hcCBTdHJpbmcgYVxuICAvLyAgIE1lcmdlcyB0d28gbWFwcyBpbnRvIG9uZS5cbiAgdmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgbWFwW2tleV0gPSBhW2tleV07XG4gICAgICB9Zm9yICh2YXIgX2tleSBpbiBiKSB7XG4gICAgICAgIG1hcFtfa2V5XSA9IGJbX2tleV07XG4gICAgICB9cmV0dXJuIG1hcDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIOKIgCBhIC4gW2FdIC0+IFthXSAtPiBCb29sXG4gIHZhciBlcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgYTsgKytpKSB7XG4gICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICB2YXIgcmF3VXJsID0gZnVuY3Rpb24gcmF3VXJsKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICByZXR1cm4gc3dhcm1VcmwgKyBcIi9ienpyOi9cIiArIGhhc2g7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFByb21pc2UgVWludDhBcnJheVxuICAvLyAgIEdldHMgdGhlIHJhdyBjb250ZW50cyBvZiBhIFN3YXJtIGhhc2ggYWRkcmVzcy5cbiAgdmFyIGRvd25sb2FkRGF0YSA9IGZ1bmN0aW9uIGRvd25sb2FkRGF0YShzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3QocmF3VXJsKHN3YXJtVXJsKShoYXNoKSwgeyByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIiB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgdmFyIGVycm9yNDA0ID0gWzUyLCA0OCwgNTIsIDMyLCAxMTIsIDk3LCAxMDMsIDEwMSwgMzIsIDExMCwgMTExLCAxMTYsIDMyLCAxMDIsIDExMSwgMTE3LCAxMTAsIDEwMCwgMTBdO1xuICAgICAgICBpZiAoZXF1YWxzKHVpbnQ4QXJyYXkpKGVycm9yNDA0KSkgdGhyb3cgXCJFcnJvciA0MDQuXCI7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5O1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyB0eXBlIEVudHJ5ID0ge1widHlwZVwiOiBTdHJpbmcsIFwiaGFzaFwiOiBTdHJpbmd9XG4gIC8vIHR5cGUgRmlsZSA9IHtcInR5cGVcIjogU3RyaW5nLCBcImRhdGFcIjogVWludDhBcnJheX1cblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFByb21pc2UgKE1hcCBTdHJpbmcgRW50cnkpXG4gIC8vICAgU29sdmVzIHRoZSBtYW5pZmVzdCBvZiBhIFN3YXJtIGFkZHJlc3MgcmVjdXJzaXZlbHkuXG4gIC8vICAgUmV0dXJucyBhIG1hcCBmcm9tIGZ1bGwgcGF0aHMgdG8gZW50cmllcy5cbiAgdmFyIGRvd25sb2FkRW50cmllcyA9IGZ1bmN0aW9uIGRvd25sb2FkRW50cmllcyhzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgdmFyIHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChoYXNoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3JtYXRzIGFuIGVudHJ5IHRvIHRoZSBTd2FybS5qcyB0eXBlLlxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChlbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGhhc2g6IGVudHJ5Lmhhc2ggfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRvIGRvd25sb2FkIGEgc2luZ2xlIGVudHJ5OlxuICAgICAgICAgICAgLy8gICBpZiB0eXBlIGlzIGJ6ei1tYW5pZmVzdCwgZ28gZGVlcGVyXG4gICAgICAgICAgICAvLyAgIGlmIG5vdCwgYWRkIGl0IHRvIHRoZSByb3V0aW5nIHRhYmxlXG4gICAgICAgICAgICB2YXIgZG93bmxvYWRFbnRyeSA9IGZ1bmN0aW9uIGRvd25sb2FkRW50cnkoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vYnp6LW1hbmlmZXN0K2pzb25cIiA/IHNlYXJjaChlbnRyeS5oYXNoKShwYXRoICsgZW50cnkucGF0aCkocm91dGVzKSA6IFByb21pc2UucmVzb2x2ZShpbXB1cmVJbnNlcnQocGF0aCArIGVudHJ5LnBhdGgpKGZvcm1hdChlbnRyeSkpKHJvdXRlcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEb3dubG9hZHMgdGhlIGluaXRpYWwgbWFuaWZlc3QgYW5kIHRoZW4gZWFjaCBlbnRyeS5cbiAgICAgICAgICAgIHJldHVybiBkb3dubG9hZERhdGEoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodG9TdHJpbmcodGV4dCkpLmVudHJpZXM7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbnRyaWVzLm1hcChkb3dubG9hZEVudHJ5KSk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc2VhcmNoKGhhc2gpKFwiXCIpKHt9KTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSAoTWFwIFN0cmluZyBTdHJpbmcpXG4gIC8vICAgU2FtZSBhcyBgZG93bmxvYWRFbnRyaWVzYCwgYnV0IHJldHVybnMgb25seSBoYXNoZXMgKG5vIHR5cGVzKS5cbiAgdmFyIGRvd25sb2FkUm91dGVzID0gZnVuY3Rpb24gZG93bmxvYWRSb3V0ZXMoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBkb3dubG9hZEVudHJpZXMoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRvTWFwKE9iamVjdC5rZXlzKGVudHJpZXMpKShPYmplY3Qua2V5cyhlbnRyaWVzKS5tYXAoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbcm91dGVdLmhhc2g7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBQcm9taXNlIChNYXAgU3RyaW5nIEZpbGUpXG4gIC8vICAgR2V0cyB0aGUgZW50aXJlIGRpcmVjdG9yeSB0cmVlIGluIGEgU3dhcm0gYWRkcmVzcy5cbiAgLy8gICBSZXR1cm5zIGEgcHJvbWlzZSBtYXBwaW5nIHBhdGhzIHRvIGZpbGUgY29udGVudHMuXG4gIHZhciBkb3dubG9hZERpcmVjdG9yeSA9IGZ1bmN0aW9uIGRvd25sb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICByZXR1cm4gZG93bmxvYWRFbnRyaWVzKHN3YXJtVXJsKShoYXNoKS50aGVuKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIHZhciBwYXRocyA9IE9iamVjdC5rZXlzKGVudHJpZXMpO1xuICAgICAgICB2YXIgaGFzaHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1twYXRoXS5oYXNoO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHR5cGVzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbcGF0aF0udHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkYXRhcyA9IGhhc2hzLm1hcChkb3dubG9hZERhdGEoc3dhcm1VcmwpKTtcbiAgICAgICAgdmFyIGZpbGVzID0gZnVuY3Rpb24gZmlsZXMoZGF0YXMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YXMubWFwKGZ1bmN0aW9uIChkYXRhLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlc1tpXSwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZGF0YXMpLnRoZW4oZnVuY3Rpb24gKGRhdGFzKSB7XG4gICAgICAgICAgcmV0dXJuIHRvTWFwKHBhdGhzKShmaWxlcyhkYXRhcykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSBTdHJpbmdcbiAgLy8gICBHZXRzIHRoZSByYXcgY29udGVudHMgb2YgYSBTd2FybSBoYXNoIGFkZHJlc3MuXG4gIC8vICAgUmV0dXJucyBhIHByb21pc2Ugd2l0aCB0aGUgZG93bmxvYWRlZCBmaWxlIHBhdGguXG4gIHZhciBkb3dubG9hZERhdGFUb0Rpc2sgPSBmdW5jdGlvbiBkb3dubG9hZERhdGFUb0Rpc2soc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzLmRvd25sb2FkKHJhd1VybChzd2FybVVybCkoaGFzaCkpKGZpbGVQYXRoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBQcm9taXNlIChNYXAgU3RyaW5nIFN0cmluZylcbiAgLy8gICBHZXRzIHRoZSBlbnRpcmUgZGlyZWN0b3J5IHRyZWUgaW4gYSBTd2FybSBhZGRyZXNzLlxuICAvLyAgIFJldHVybnMgYSBwcm9taXNlIG1hcHBpbmcgcGF0aHMgdG8gZmlsZSBjb250ZW50cy5cbiAgdmFyIGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrID0gZnVuY3Rpb24gZG93bmxvYWREaXJlY3RvcnlUb0Rpc2soc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gZG93bmxvYWRSb3V0ZXMoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHJvdXRpbmdUYWJsZSkge1xuICAgICAgICAgIHZhciBkb3dubG9hZHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciByb3V0ZSBpbiByb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBmaWxlUGF0aCA9IHBhdGguam9pbihkaXJQYXRoLCByb3V0ZSk7XG4gICAgICAgICAgICAgIGRvd25sb2Fkcy5wdXNoKGRvd25sb2FkRGF0YVRvRGlzayhzd2FybVVybCkocm91dGluZ1RhYmxlW3JvdXRlXSkoZmlsZVBhdGgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZG93bmxvYWRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXJQYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gVWludDhBcnJheSAtPiBQcm9taXNlIFN0cmluZ1xuICAvLyAgIFVwbG9hZHMgcmF3IGRhdGEgdG8gU3dhcm0uXG4gIC8vICAgUmV0dXJucyBhIHByb21pc2Ugd2l0aCB0aGUgdXBsb2FkZWQgaGFzaC5cbiAgdmFyIHVwbG9hZERhdGEgPSBmdW5jdGlvbiB1cGxvYWREYXRhKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdChzd2FybVVybCArIFwiL2J6enI6L1wiLCB7XG4gICAgICAgIGJvZHk6IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZnJvbVN0cmluZyhkYXRhKSA6IGRhdGEsXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBGaWxlIC0+IFByb21pc2UgU3RyaW5nXG4gIC8vICAgVXBsb2FkcyBhIGZpbGUgdG8gdGhlIFN3YXJtIG1hbmlmZXN0IGF0IGEgZ2l2ZW4gaGFzaCwgdW5kZXIgYSBzcGVjaWZpY1xuICAvLyAgIHJvdXRlLiBSZXR1cm5zIGEgcHJvbWlzZSBjb250YWluaW5nIHRoZSB1cGxvYWRlZCBoYXNoLlxuICAvLyAgIEZJWE1FOiBmb3Igc29tZSByZWFzb25zIFN3YXJtLUdhdGV3YXlzIGlzIHNvbWV0aW1lcyByZXR1cm5pbmdcbiAgLy8gICBlcnJvciA0MDTCoChiYWQgcmVxdWVzdCksIHNvIHdlIHJldHJ5IHVwIHRvIDMgdGltZXMuIFdoeT9cbiAgdmFyIHVwbG9hZFRvTWFuaWZlc3QgPSBmdW5jdGlvbiB1cGxvYWRUb01hbmlmZXN0KHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgIHZhciBhdHRlbXB0ID0gZnVuY3Rpb24gYXR0ZW1wdChuKSB7XG4gICAgICAgICAgICB2YXIgc2xhc2hSb3V0ZSA9IHJvdXRlWzBdID09PSBcIi9cIiA/IHJvdXRlIDogXCIvXCIgKyByb3V0ZTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBzd2FybVVybCArIFwiL2J6ejovXCIgKyBoYXNoICsgc2xhc2hSb3V0ZTtcbiAgICAgICAgICAgIHZhciBvcHQgPSB7XG4gICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBmaWxlLnR5cGUgfSxcbiAgICAgICAgICAgICAgYm9keTogZmlsZS5kYXRhIH07XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdCh1cmwsIG9wdCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmluZGV4T2YoXCJlcnJvclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbiA+IDAgJiYgYXR0ZW1wdChuIC0gMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBhdHRlbXB0KDMpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFN0cmluZyAtPiB7dHlwZTogU3RyaW5nLCBkYXRhOiBVaW50OEFycmF5fSAtPiBQcm9taXNlIFN0cmluZ1xuICB2YXIgdXBsb2FkRmlsZSA9IGZ1bmN0aW9uIHVwbG9hZEZpbGUoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIHJldHVybiB1cGxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpKHsgXCJcIjogZmlsZSB9KTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSBTdHJpbmdcbiAgdmFyIHVwbG9hZEZpbGVGcm9tRGlzayA9IGZ1bmN0aW9uIHVwbG9hZEZpbGVGcm9tRGlzayhzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlUGF0aCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdXBsb2FkRmlsZShzd2FybVVybCkoeyB0eXBlOiBtaW1ldHlwZS5sb29rdXAoZmlsZVBhdGgpLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gTWFwIFN0cmluZyBGaWxlIC0+IFByb21pc2UgU3RyaW5nXG4gIC8vICAgVXBsb2FkcyBhIGRpcmVjdG9yeSB0byBTd2FybS4gVGhlIGRpcmVjdG9yeSBpc1xuICAvLyAgIHJlcHJlc2VudGVkIGFzIGEgbWFwIG9mIHJvdXRlcyBhbmQgZmlsZXMuXG4gIC8vICAgQSBkZWZhdWx0IHBhdGggaXMgZW5jb2RlZCBieSBoYXZpbmcgYSBcIlwiIHJvdXRlLlxuICB2YXIgdXBsb2FkRGlyZWN0b3J5ID0gZnVuY3Rpb24gdXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkaXJlY3RvcnkpIHtcbiAgICAgIHJldHVybiB1cGxvYWREYXRhKHN3YXJtVXJsKShcInt9XCIpLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgdmFyIHVwbG9hZFJvdXRlID0gZnVuY3Rpb24gdXBsb2FkUm91dGUocm91dGUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRUb01hbmlmZXN0KHN3YXJtVXJsKShoYXNoKShyb3V0ZSkoZGlyZWN0b3J5W3JvdXRlXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVwbG9hZFRvSGFzaCA9IGZ1bmN0aW9uIHVwbG9hZFRvSGFzaChoYXNoLCByb3V0ZSkge1xuICAgICAgICAgIHJldHVybiBoYXNoLnRoZW4odXBsb2FkUm91dGUocm91dGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpcmVjdG9yeSkucmVkdWNlKHVwbG9hZFRvSGFzaCwgUHJvbWlzZS5yZXNvbHZlKGhhc2gpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFByb21pc2UgU3RyaW5nXG4gIHZhciB1cGxvYWREYXRhRnJvbURpc2sgPSBmdW5jdGlvbiB1cGxvYWREYXRhRnJvbURpc2soc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZVBhdGgpLnRoZW4odXBsb2FkRGF0YShzd2FybVVybCkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IE51bGxhYmxlIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSBTdHJpbmdcbiAgdmFyIHVwbG9hZERpcmVjdG9yeUZyb21EaXNrID0gZnVuY3Rpb24gdXBsb2FkRGlyZWN0b3J5RnJvbURpc2soc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlZmF1bHRQYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRpclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzLmRpcmVjdG9yeVRyZWUoZGlyUGF0aCkudGhlbihmdW5jdGlvbiAoZnVsbFBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZ1bGxQYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZShwYXRoKTtcbiAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoZGF0YXMpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IGZ1bGxQYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoZGlyUGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdHlwZXMgPSBmdWxsUGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtaW1ldHlwZS5sb29rdXAocGF0aCkgfHwgXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b01hcChwYXRocykoZGF0YXMubWFwKGZ1bmN0aW9uIChkYXRhLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGVzW2ldLCBkYXRhOiBkYXRhIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRpcmVjdG9yeSkge1xuICAgICAgICAgIHJldHVybiBtZXJnZShkZWZhdWx0UGF0aCA/IHsgXCJcIjogZGlyZWN0b3J5W2RlZmF1bHRQYXRoXSB9IDoge30pKGRpcmVjdG9yeSk7XG4gICAgICAgIH0pLnRoZW4odXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFVwbG9hZEluZm8gLT4gUHJvbWlzZSBTdHJpbmdcbiAgLy8gICBTaW1wbGlmaWVkIG11bHRpLXR5cGUgdXBsb2FkIHdoaWNoIGNhbGxzIHRoZSBjb3JyZWN0XG4gIC8vICAgb25lIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudCBnaXZlbi5cbiAgdmFyIF91cGxvYWQgPSBmdW5jdGlvbiBfdXBsb2FkKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIC8vIFVwbG9hZCByYXcgZGF0YSBmcm9tIGJyb3dzZXJcbiAgICAgIGlmIChhcmcucGljayA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHBpY2suZGF0YSgpLnRoZW4odXBsb2FkRGF0YShzd2FybVVybCkpO1xuXG4gICAgICAgIC8vIFVwbG9hZCBhIGZpbGUgZnJvbSBicm93c2VyXG4gICAgICB9IGVsc2UgaWYgKGFyZy5waWNrID09PSBcImZpbGVcIikge1xuICAgICAgICByZXR1cm4gcGljay5maWxlKCkudGhlbih1cGxvYWRGaWxlKHN3YXJtVXJsKSk7XG5cbiAgICAgICAgLy8gVXBsb2FkIGEgZGlyZWN0b3J5IGZyb20gYnJvd3NlclxuICAgICAgfSBlbHNlIGlmIChhcmcucGljayA9PT0gXCJkaXJlY3RvcnlcIikge1xuICAgICAgICByZXR1cm4gcGljay5kaXJlY3RvcnkoKS50aGVuKHVwbG9hZERpcmVjdG9yeShzd2FybVVybCkpO1xuXG4gICAgICAgIC8vIFVwbG9hZCBkaXJlY3RvcnkvZmlsZSBmcm9tIGRpc2tcbiAgICAgIH0gZWxzZSBpZiAoYXJnLnBhdGgpIHtcbiAgICAgICAgc3dpdGNoIChhcmcua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkRGF0YUZyb21EaXNrKHN3YXJtVXJsKShhcmcucGF0aCk7XG4gICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRGaWxlRnJvbURpc2soc3dhcm1VcmwpKGFyZy5wYXRoKTtcbiAgICAgICAgICBjYXNlIFwiZGlyZWN0b3J5XCI6XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkRGlyZWN0b3J5RnJvbURpc2soc3dhcm1VcmwpKGFyZy5kZWZhdWx0RmlsZSkoYXJnLnBhdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwbG9hZCBVVEYtOCBzdHJpbmcgb3IgcmF3IGRhdGEgKGJ1ZmZlcilcbiAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCB8fCB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB1cGxvYWREYXRhKHN3YXJtVXJsKShhcmcpO1xuXG4gICAgICAgIC8vIFVwbG9hZCBkaXJlY3Rvcnkgd2l0aCBKU09OXG4gICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gdXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKShhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQmFkIGFyZ3VtZW50c1wiKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IE51bGxhYmxlIFN0cmluZyAtPiBQcm9taXNlIChTdHJpbmcgfCBVaW50OEFycmF5IHwgTWFwIFN0cmluZyBVaW50OEFycmF5KVxuICAvLyAgIFNpbXBsaWZpZWQgbXVsdGktdHlwZSBkb3dubG9hZCB3aGljaCBjYWxscyB0aGUgY29ycmVjdCBmdW5jdGlvbiBiYXNlZCBvblxuICAvLyAgIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudCBnaXZlbiwgYW5kIG9uIHdoZXRoZXIgdGhlIFN3d2FybSBhZGRyZXNzIGhhcyBhXG4gIC8vICAgZGlyZWN0b3J5IG9yIGEgZmlsZS5cbiAgdmFyIF9kb3dubG9hZCA9IGZ1bmN0aW9uIF9kb3dubG9hZChzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBpc0RpcmVjdG9yeShzd2FybVVybCkoaGFzaCkudGhlbihmdW5jdGlvbiAoaXNEaXIpIHtcbiAgICAgICAgICBpZiAoaXNEaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoID8gZG93bmxvYWREaXJlY3RvcnlUb0Rpc2soc3dhcm1VcmwpKGhhc2gpKHBhdGgpIDogZG93bmxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpKGhhc2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aCA/IGRvd25sb2FkRGF0YVRvRGlzayhzd2FybVVybCkoaGFzaCkocGF0aCkgOiBkb3dubG9hZERhdGEoc3dhcm1VcmwpKGhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFByb21pc2UgU3RyaW5nXG4gIC8vICAgRG93bmxvYWRzIHRoZSBTd2FybSBiaW5hcmllcyBpbnRvIGEgcGF0aC4gUmV0dXJucyBhIHByb21pc2UgdGhhdCBvbmx5XG4gIC8vICAgcmVzb2x2ZXMgd2hlbiB0aGUgZXhhY3QgU3dhcm0gZmlsZSBpcyB0aGVyZSwgYW5kIHZlcmlmaWVkIHRvIGJlIGNvcnJlY3QuXG4gIC8vICAgSWYgaXQgd2FzIGFscmVhZHkgdGhlcmUgdG8gYmVnaW4gd2l0aCwgc2tpcHMgdGhlIGRvd25sb2FkLlxuICB2YXIgZG93bmxvYWRCaW5hcnkgPSBmdW5jdGlvbiBkb3dubG9hZEJpbmFyeShwYXRoLCBhcmNoaXZlcykge1xuICAgIHZhciBzeXN0ZW0gPSBvcy5wbGF0Zm9ybSgpLnJlcGxhY2UoXCJ3aW4zMlwiLCBcIndpbmRvd3NcIikgKyBcIi1cIiArIChvcy5hcmNoKCkgPT09IFwieDY0XCIgPyBcImFtZDY0XCIgOiBcIjM4NlwiKTtcbiAgICB2YXIgYXJjaGl2ZSA9IChhcmNoaXZlcyB8fCBkZWZhdWx0QXJjaGl2ZXMpW3N5c3RlbV07XG4gICAgdmFyIGFyY2hpdmVVcmwgPSBkb3dubG9hZFVybCArIGFyY2hpdmUuYXJjaGl2ZSArIFwiLnRhci5nelwiO1xuICAgIHZhciBhcmNoaXZlTUQ1ID0gYXJjaGl2ZS5hcmNoaXZlTUQ1O1xuICAgIHZhciBiaW5hcnlNRDUgPSBhcmNoaXZlLmJpbmFyeU1ENTtcbiAgICByZXR1cm4gZmlsZXMuc2FmZURvd25sb2FkQXJjaGl2ZWQoYXJjaGl2ZVVybCkoYXJjaGl2ZU1ENSkoYmluYXJ5TUQ1KShwYXRoKTtcbiAgfTtcblxuICAvLyB0eXBlIFN3YXJtU2V0dXAgPSB7XG4gIC8vICAgYWNjb3VudCA6IFN0cmluZyxcbiAgLy8gICBwYXNzd29yZCA6IFN0cmluZyxcbiAgLy8gICBkYXRhRGlyIDogU3RyaW5nLFxuICAvLyAgIGJpblBhdGggOiBTdHJpbmcsXG4gIC8vICAgZW5zQXBpIDogU3RyaW5nLFxuICAvLyAgIG9uRG93bmxvYWRQcm9ncmVzcyA6IE51bWJlciB+PiAoKSxcbiAgLy8gICBhcmNoaXZlcyA6IFt7XG4gIC8vICAgICBhcmNoaXZlOiBTdHJpbmcsXG4gIC8vICAgICBiaW5hcnlNRDU6IFN0cmluZyxcbiAgLy8gICAgIGFyY2hpdmVNRDU6IFN0cmluZ1xuICAvLyAgIH1dXG4gIC8vIH1cblxuICAvLyBTd2FybVNldHVwIH4+IFByb21pc2UgUHJvY2Vzc1xuICAvLyAgIFN0YXJ0cyB0aGUgU3dhcm0gcHJvY2Vzcy5cbiAgdmFyIHN0YXJ0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0YXJ0UHJvY2Vzcyhzd2FybVNldHVwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBzcGF3biA9IGNoaWxkX3Byb2Nlc3Muc3Bhd247XG5cblxuICAgICAgdmFyIGhhc1N0cmluZyA9IGZ1bmN0aW9uIGhhc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gKCcnICsgYnVmZmVyKS5pbmRleE9mKHN0cikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBhY2NvdW50ID0gc3dhcm1TZXR1cC5hY2NvdW50LFxuICAgICAgICAgIHBhc3N3b3JkID0gc3dhcm1TZXR1cC5wYXNzd29yZCxcbiAgICAgICAgICBkYXRhRGlyID0gc3dhcm1TZXR1cC5kYXRhRGlyLFxuICAgICAgICAgIGVuc0FwaSA9IHN3YXJtU2V0dXAuZW5zQXBpLFxuICAgICAgICAgIHByaXZhdGVLZXkgPSBzd2FybVNldHVwLnByaXZhdGVLZXk7XG5cblxuICAgICAgdmFyIFNUQVJUVVBfVElNRU9VVF9TRUNTID0gMztcbiAgICAgIHZhciBXQUlUSU5HX1BBU1NXT1JEID0gMDtcbiAgICAgIHZhciBTVEFSVElORyA9IDE7XG4gICAgICB2YXIgTElTVEVOSU5HID0gMjtcbiAgICAgIHZhciBQQVNTV09SRF9QUk9NUFRfSE9PSyA9IFwiUGFzc3BocmFzZVwiO1xuICAgICAgdmFyIExJU1RFTklOR19IT09LID0gXCJTd2FybSBodHRwIHByb3h5IHN0YXJ0ZWRcIjtcblxuICAgICAgdmFyIHN0YXRlID0gV0FJVElOR19QQVNTV09SRDtcblxuICAgICAgdmFyIHN3YXJtUHJvY2VzcyA9IHNwYXduKHN3YXJtU2V0dXAuYmluUGF0aCwgWyctLWJ6emFjY291bnQnLCBhY2NvdW50IHx8IHByaXZhdGVLZXksICctLWRhdGFkaXInLCBkYXRhRGlyLCAnLS1lbnMtYXBpJywgZW5zQXBpXSk7XG5cbiAgICAgIHZhciBoYW5kbGVQcm9jZXNzT3V0cHV0ID0gZnVuY3Rpb24gaGFuZGxlUHJvY2Vzc091dHB1dChkYXRhKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gV0FJVElOR19QQVNTV09SRCAmJiBoYXNTdHJpbmcoUEFTU1dPUkRfUFJPTVBUX0hPT0spKGRhdGEpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVJUSU5HO1xuICAgICAgICAgICAgc3dhcm1Qcm9jZXNzLnN0ZGluLndyaXRlKHBhc3N3b3JkICsgJ1xcbicpO1xuICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzU3RyaW5nKExJU1RFTklOR19IT09LKShkYXRhKSkge1xuICAgICAgICAgIHN0YXRlID0gTElTVEVOSU5HO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKHN3YXJtUHJvY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHN3YXJtUHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCBoYW5kbGVQcm9jZXNzT3V0cHV0KTtcbiAgICAgIHN3YXJtUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCBoYW5kbGVQcm9jZXNzT3V0cHV0KTtcbiAgICAgIC8vc3dhcm1Qcm9jZXNzLm9uKCdjbG9zZScsICgpID0+IHNldFRpbWVvdXQocmVzdGFydCwgMjAwMCkpO1xuXG4gICAgICB2YXIgcmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBzdGFydFByb2Nlc3Moc3dhcm1TZXR1cCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgfTtcbiAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNvdWxkbid0IHN0YXJ0IHN3YXJtIHByb2Nlc3MuXCIpKTtcbiAgICAgIH07XG4gICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZXJyb3IsIDIwMDAwKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBQcm9jZXNzIH4+IFByb21pc2UgKClcbiAgLy8gICBTdG9wcyB0aGUgU3dhcm0gcHJvY2Vzcy5cbiAgdmFyIHN0b3BQcm9jZXNzID0gZnVuY3Rpb24gc3RvcFByb2Nlc3MocHJvY2Vzcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9jZXNzLnN0ZGVyci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuICAgICAgcHJvY2Vzcy5zdGRpbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgICBwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzKCdleGl0Jyk7XG4gICAgICBwcm9jZXNzLmtpbGwoJ1NJR0lOVCcpO1xuXG4gICAgICB2YXIga2lsbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Mua2lsbCgnU0lHS0lMTCcpO1xuICAgICAgfSwgODAwMCk7XG5cbiAgICAgIHByb2Nlc3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChraWxsVGltZW91dCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFN3YXJtU2V0dXAgLT4gKFN3YXJtQVBJIC0+IFByb21pc2UgKCkpIC0+IFByb21pc2UgKClcbiAgLy8gICBSZWNlaXZlcyBhIFN3YXJtIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBJdCB0aGVuXG4gIC8vICAgY2hlY2tzIGlmIGEgbG9jYWwgU3dhcm0gbm9kZSBpcyBydW5uaW5nLiBJZiBubyBsb2NhbCBTd2FybSBpcyBmb3VuZCwgaXRcbiAgLy8gICBkb3dubG9hZHMgdGhlIFN3YXJtIGJpbmFyaWVzIHRvIHRoZSBkYXRhRGlyIChpZiBub3QgdGhlcmUpLCBjaGVja3N1bXMsXG4gIC8vICAgc3RhcnRzIHRoZSBTd2FybSBwcm9jZXNzIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhbiBBUElcbiAgLy8gICBvYmplY3QgdXNpbmcgdGhlIGxvY2FsIG5vZGUuIFRoYXQgY2FsbGJhY2sgbXVzdCByZXR1cm4gYSBwcm9taXNlIHdoaWNoXG4gIC8vICAgd2lsbCByZXNvbHZlIHdoZW4gaXQgaXMgZG9uZSB1c2luZyB0aGUgQVBJLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuXG4gIC8vICAgY2xvc2UgdGhlIFN3YXJtIHByb2Nlc3MgcHJvcGVybHkuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGVcbiAgLy8gICB1c2VyIGlzIGRvbmUgd2l0aCB0aGUgQVBJIGFuZCB0aGUgU3dhcm0gcHJvY2VzcyBpcyBjbG9zZWQuXG4gIC8vICAgVE9ETzogY2hlY2sgaWYgU3dhcm0gcHJvY2VzcyBpcyBhbHJlYWR5IHJ1bm5pbmcgKGltcHJvdmUgYGlzQXZhaWxhYmxlYClcbiAgdmFyIGxvY2FsID0gZnVuY3Rpb24gbG9jYWwoc3dhcm1TZXR1cCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodXNlQVBJKSB7XG4gICAgICByZXR1cm4gX2lzQXZhaWxhYmxlKFwiaHR0cDovL2xvY2FsaG9zdDo4NTAwXCIpLnRoZW4oZnVuY3Rpb24gKGlzQXZhaWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBpc0F2YWlsYWJsZSA/IHVzZUFQSShhdChcImh0dHA6Ly9sb2NhbGhvc3Q6ODUwMFwiKSkudGhlbihmdW5jdGlvbiAoKSB7fSkgOiBkb3dubG9hZEJpbmFyeShzd2FybVNldHVwLmJpblBhdGgsIHN3YXJtU2V0dXAuYXJjaGl2ZXMpLm9uRGF0YShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiAoc3dhcm1TZXR1cC5vblByb2dyZXNzIHx8IGZ1bmN0aW9uICgpIHt9KShkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdGFydFByb2Nlc3Moc3dhcm1TZXR1cCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gdXNlQVBJKGF0KFwiaHR0cDovL2xvY2FsaG9zdDo4NTAwXCIpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHN0b3BQcm9jZXNzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gU3RyaW5nIH4+IFByb21pc2UgQm9vbFxuICAvLyAgIFJldHVybnMgdHJ1ZSBpZiBTd2FybSBpcyBhdmFpbGFibGUgb24gYHVybGAuXG4gIC8vICAgUGVyZm9tcyBhIHRlc3QgdXBsb2FkIHRvIGRldGVybWluZSB0aGF0LlxuICAvLyAgIFRPRE86IGltcHJvdmUgdGhpcz9cbiAgdmFyIF9pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uIF9pc0F2YWlsYWJsZShzd2FybVVybCkge1xuICAgIHZhciB0ZXN0RmlsZSA9IFwidGVzdFwiO1xuICAgIHZhciB0ZXN0SGFzaCA9IFwiYzlhOTljN2QzMjZkY2M2MzE2ZjMyZmUyNjI1YjMxMWY2ZGM0OWExNzVlNjg3NzY4MWRlZDkzMTM3ZDM1NjllN1wiO1xuICAgIHJldHVybiB1cGxvYWREYXRhKHN3YXJtVXJsKSh0ZXN0RmlsZSkudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIGhhc2ggPT09IHRlc3RIYXNoO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTdHJpbmcgLT4gU3RyaW5nIH4+IFByb21pc2UgQm9vbFxuICAvLyAgIFJldHVybnMgYSBQcm9taXNlIHdoaWNoIGlzIHRydWUgaWYgdGhhdCBTd2FybSBhZGRyZXNzIGlzIGEgZGlyZWN0b3J5LlxuICAvLyAgIERldGVybWluZXMgdGhhdCBieSBjaGVja2luZyB0aGF0IGl0IChpKSBpcyBhIEpTT04sIChpaSkgaGFzIGEgLmVudHJpZXMuXG4gIC8vICAgVE9ETzogaW1wcm92ZSB0aGlzP1xuICB2YXIgaXNEaXJlY3RvcnkgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeShzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIGRvd25sb2FkRGF0YShzd2FybVVybCkoaGFzaCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAhIUpTT04ucGFyc2UodG9TdHJpbmcoZGF0YSkpLmVudHJpZXM7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLy8gVW5jdXJyaWVzIGEgZnVuY3Rpb247IHVzZWQgdG8gYWxsb3cgdGhlIGYoeCx5LHopIHN0eWxlIG9uIGV4cG9ydHMuXG4gIHZhciB1bmN1cnJ5ID0gZnVuY3Rpb24gdW5jdXJyeShmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIC8vIEhhcmRjb2RlZCBiZWNhdXNlIGVmZmljaWVuY3kgKGBhcmd1bWVudHNgIGlzIHZlcnkgc2xvdykuXG4gICAgICBpZiAodHlwZW9mIGEgIT09IFwidW5kZWZpbmVkXCIpIHAgPSBmKGEpO1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSBcInVuZGVmaW5lZFwiKSBwID0gZihiKTtcbiAgICAgIGlmICh0eXBlb2YgYyAhPT0gXCJ1bmRlZmluZWRcIikgcCA9IGYoYyk7XG4gICAgICBpZiAodHlwZW9mIGQgIT09IFwidW5kZWZpbmVkXCIpIHAgPSBmKGQpO1xuICAgICAgaWYgKHR5cGVvZiBlICE9PSBcInVuZGVmaW5lZFwiKSBwID0gZihlKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH07XG4gIH07XG5cbiAgLy8gKCkgLT4gUHJvbWlzZSBCb29sXG4gIC8vICAgTm90IHN1cmUgaG93IHRvIG1vY2sgU3dhcm0gdG8gdGVzdCBpdCBwcm9wZXJseS4gSWRlYXM/XG4gIHZhciB0ZXN0ID0gZnVuY3Rpb24gdGVzdCgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICB9O1xuXG4gIC8vIFVpbnQ4QXJyYXkgLT4gU3RyaW5nXG4gIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYnl0ZXMudG9TdHJpbmcoYnl0ZXMuZnJvbVVpbnQ4QXJyYXkodWludDhBcnJheSkpO1xuICB9O1xuXG4gIC8vIFN0cmluZyAtPiBVaW50OEFycmF5XG4gIHZhciBmcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICByZXR1cm4gYnl0ZXMudG9VaW50OEFycmF5KGJ5dGVzLmZyb21TdHJpbmcoc3RyaW5nKSk7XG4gIH07XG5cbiAgLy8gU3RyaW5nIC0+IFN3YXJtQVBJXG4gIC8vICAgRml4ZXMgdGhlIGBzd2FybVVybGAsIHJldHVybmluZyBhbiBBUEkgd2hlcmUgeW91IGRvbid0IGhhdmUgdG8gcGFzcyBpdC5cbiAgdmFyIGF0ID0gZnVuY3Rpb24gYXQoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZG93bmxvYWQ6IGZ1bmN0aW9uIGRvd25sb2FkKGhhc2gsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF9kb3dubG9hZChzd2FybVVybCkoaGFzaCkocGF0aCk7XG4gICAgICB9LFxuICAgICAgZG93bmxvYWREYXRhOiB1bmN1cnJ5KGRvd25sb2FkRGF0YShzd2FybVVybCkpLFxuICAgICAgZG93bmxvYWREYXRhVG9EaXNrOiB1bmN1cnJ5KGRvd25sb2FkRGF0YVRvRGlzayhzd2FybVVybCkpLFxuICAgICAgZG93bmxvYWREaXJlY3Rvcnk6IHVuY3VycnkoZG93bmxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpKSxcbiAgICAgIGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrOiB1bmN1cnJ5KGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrKHN3YXJtVXJsKSksXG4gICAgICBkb3dubG9hZEVudHJpZXM6IHVuY3VycnkoZG93bmxvYWRFbnRyaWVzKHN3YXJtVXJsKSksXG4gICAgICBkb3dubG9hZFJvdXRlczogdW5jdXJyeShkb3dubG9hZFJvdXRlcyhzd2FybVVybCkpLFxuICAgICAgaXNBdmFpbGFibGU6IGZ1bmN0aW9uIGlzQXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gX2lzQXZhaWxhYmxlKHN3YXJtVXJsKTtcbiAgICAgIH0sXG4gICAgICB1cGxvYWQ6IGZ1bmN0aW9uIHVwbG9hZChhcmcpIHtcbiAgICAgICAgcmV0dXJuIF91cGxvYWQoc3dhcm1VcmwpKGFyZyk7XG4gICAgICB9LFxuICAgICAgdXBsb2FkRGF0YTogdW5jdXJyeSh1cGxvYWREYXRhKHN3YXJtVXJsKSksXG4gICAgICB1cGxvYWRGaWxlOiB1bmN1cnJ5KHVwbG9hZEZpbGUoc3dhcm1VcmwpKSxcbiAgICAgIHVwbG9hZEZpbGVGcm9tRGlzazogdW5jdXJyeSh1cGxvYWRGaWxlKHN3YXJtVXJsKSksXG4gICAgICB1cGxvYWREYXRhRnJvbURpc2s6IHVuY3VycnkodXBsb2FkRGF0YUZyb21EaXNrKHN3YXJtVXJsKSksXG4gICAgICB1cGxvYWREaXJlY3Rvcnk6IHVuY3VycnkodXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSksXG4gICAgICB1cGxvYWREaXJlY3RvcnlGcm9tRGlzazogdW5jdXJyeSh1cGxvYWREaXJlY3RvcnlGcm9tRGlzayhzd2FybVVybCkpLFxuICAgICAgdXBsb2FkVG9NYW5pZmVzdDogdW5jdXJyeSh1cGxvYWRUb01hbmlmZXN0KHN3YXJtVXJsKSksXG4gICAgICBwaWNrOiBwaWNrLFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIGZyb21TdHJpbmc6IGZyb21TdHJpbmcsXG4gICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYXQ6IGF0LFxuICAgIGxvY2FsOiBsb2NhbCxcbiAgICBkb3dubG9hZDogX2Rvd25sb2FkLFxuICAgIGRvd25sb2FkQmluYXJ5OiBkb3dubG9hZEJpbmFyeSxcbiAgICBkb3dubG9hZERhdGE6IGRvd25sb2FkRGF0YSxcbiAgICBkb3dubG9hZERhdGFUb0Rpc2s6IGRvd25sb2FkRGF0YVRvRGlzayxcbiAgICBkb3dubG9hZERpcmVjdG9yeTogZG93bmxvYWREaXJlY3RvcnksXG4gICAgZG93bmxvYWREaXJlY3RvcnlUb0Rpc2s6IGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrLFxuICAgIGRvd25sb2FkRW50cmllczogZG93bmxvYWRFbnRyaWVzLFxuICAgIGRvd25sb2FkUm91dGVzOiBkb3dubG9hZFJvdXRlcyxcbiAgICBpc0F2YWlsYWJsZTogX2lzQXZhaWxhYmxlLFxuICAgIHN0YXJ0UHJvY2Vzczogc3RhcnRQcm9jZXNzLFxuICAgIHN0b3BQcm9jZXNzOiBzdG9wUHJvY2VzcyxcbiAgICB1cGxvYWQ6IF91cGxvYWQsXG4gICAgdXBsb2FkRGF0YTogdXBsb2FkRGF0YSxcbiAgICB1cGxvYWREYXRhRnJvbURpc2s6IHVwbG9hZERhdGFGcm9tRGlzayxcbiAgICB1cGxvYWRGaWxlOiB1cGxvYWRGaWxlLFxuICAgIHVwbG9hZEZpbGVGcm9tRGlzazogdXBsb2FkRmlsZUZyb21EaXNrLFxuICAgIHVwbG9hZERpcmVjdG9yeTogdXBsb2FkRGlyZWN0b3J5LFxuICAgIHVwbG9hZERpcmVjdG9yeUZyb21EaXNrOiB1cGxvYWREaXJlY3RvcnlGcm9tRGlzayxcbiAgICB1cGxvYWRUb01hbmlmZXN0OiB1cGxvYWRUb01hbmlmZXN0LFxuICAgIHBpY2s6IHBpY2ssXG4gICAgaGFzaDogaGFzaCxcbiAgICBmcm9tU3RyaW5nOiBmcm9tU3RyaW5nLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xufTsiXX0=
